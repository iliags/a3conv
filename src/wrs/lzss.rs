/// LZSS algorithm based on QuickBMS LZSS implementation

// Note: The first few iterations are a direct translation of the C code, it will be refactored into idiomatic Rust later.
pub fn unlzss(src_data: &[u8], dest_data: &mut [u8]) -> Result<(), &'static str> {
    let ei = 12;
    let ej = 4;
    let p = 2;
    let rless = p;
    let init_char: u8 = 0x20;

    let mut n = 1 << ei;
    let mut f = 1 << ej;

    let mut slide_window = vec![init_char; n + f];

    let mut r = (n - f) - rless;
    n -= 1;
    f -= 1;

    let mut flags: u32 = 0;
    let mut src_index = 0;
    let mut dest_index = 0;
    loop {
        flags >>= 1;

        if flags & 0x100 == 0 {
            if src_index >= src_data.len() {
                break;
            }
            flags = src_data[src_index] as u32 | 0xff00;

            src_index += 1;
        }
        if flags & 1 != 0 {
            if src_index >= src_data.len() {
                break;
            }
            let c = src_data[src_index] as u32;
            src_index += 1;

            if dest_index >= dest_data.len() {
                return Err("Error: dest_index out of bounds");
            }

            dest_data[dest_index] = c as u8;
            dest_index += 1;

            slide_window[r] = c as u8;
            r = (r + 1) & n;
        } else {
            if src_index >= src_data.len() {
                break;
            }
            let mut i = src_data[src_index] as u32;
            src_index += 1;

            if src_index >= src_data.len() {
                break;
            }
            let mut j = src_data[src_index] as u32;
            src_index += 1;

            i |= (j >> ej) << 8;
            j = (j & f as u32) + p as u32;

            for k in 0..=j {
                let win_index = ((i + k) as usize) & n;
                let c = slide_window[win_index] as u32;

                if dest_index >= dest_data.len() {
                    return Err("Error: dest_index out of bounds");
                }
                dest_data[dest_index] = c as u8;
                dest_index += 1;

                slide_window[r] = c as u8;
                r = (r + 1) & n;
            }
        }
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    // Known good compressed and decompressed data from an Acknex WRS archive
    const COMPRESSED_DATA: &'static [u8] = &[
        223, 10, 5, 1, 8, 0, 242, 240, 35, 0, 63, 31, 0, 44, 1, 44, 1, 242, 241, 1, 15, 252, 19,
        15, 29, 6, 1, 36, 0, 1, 0, 128, 99, 2, 224, 253, 255, 72, 15, 90, 15, 0, 228, 109, 15, 24,
        127, 15, 145, 15, 155, 6, 12, 16, 175, 15, 193, 15, 211, 15, 0, 229, 15, 247, 15, 9, 31,
        27, 31, 45, 31, 63, 31, 81, 31, 99, 31, 0, 117, 31, 135, 31, 153, 31, 171, 31, 189, 31,
        207, 31, 225, 31, 243, 31, 0, 5, 47, 23, 47, 41, 47, 59, 47, 77, 47, 95, 47, 113, 47, 131,
        47, 0, 149, 47, 167, 47, 185, 47, 203, 47, 221, 47, 239, 47, 1, 63, 19, 63, 0, 37, 63, 55,
        63, 73, 63, 91, 63, 109, 63, 127, 63, 145, 63, 157, 56,
    ];
    const _COMPRESSED_SIZE: usize = 145;

    const DECOMPRESSED_DATA: &'static [u8] = &[
        10, 5, 1, 8, 0, 0, 0, 0, 35, 0, 31, 0, 44, 1, 44, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 1, 36, 0, 1, 0, 128, 2, 224, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 228, 0, 228, 0, 228, 0, 228, 0, 228, 0, 228, 0, 228, 0, 228,
        0, 228, 0, 228, 0, 228, 0, 228, 0, 228, 0, 228, 0, 228, 0, 228, 0, 228, 0, 228, 0, 228, 0,
        228, 0, 228, 0, 228, 0, 228, 0, 228, 0, 228, 0, 228, 0, 228, 0, 228, 0, 228, 0, 228, 0,
        228, 0, 228, 0, 12, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    ];
    const DECOMPRESSED_SIZE: usize = 961;

    #[test]
    fn test_unlzss() {
        let mut output = vec![0u8; DECOMPRESSED_SIZE];

        match unlzss(COMPRESSED_DATA, &mut output) {
            Ok(_) => {
                assert_eq!(output.len(), DECOMPRESSED_SIZE);
                assert_eq!(output, DECOMPRESSED_DATA);
            }
            Err(e) => panic!("Error: {}", e),
        }
    }
}
